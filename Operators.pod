=begin pod

=head1 NAME

perlop - Perl operators and precedence

=head1 DESCRIPTION

A (hopefully) comprehensive list of Perl 5 operators with their Perl 6
equivalents with notes on variations between them where necessary.

=head1 NOTE

I will I<not> be explaining the operators in detail. This document is an
attempt to guide you from the operators in Perl 5's perlop document to
their equivalents in Perl 6. For full documentation on the Perl 6
equivalents, please see the Perl 6 documentation.

=head1 SOURCES

I'm taking my information from L<http://doc.perl6.org> (in particular,
L<http://doc.perl6.org/language/operators>), supplemented by the
design documents at L<http://design.perl6.org/> and input from the denizens
of #perl6 on irc.freenode.org

=head2 Operator Precedence and Associativity

The operator precedence table is somewhat different in Perl 6 than it is in
Perl 5, so I will not detail it here. If you need to know the precedence and
associativity of a given operator in Perl 6, refer to
L<http://doc.perl6.org/language/operators#Operator_Precedence>.

=head2 Terms and List Operators

The things listed in Perl 5's perlop document as unary and list operators in
this section tend to be things that can also be thought of as functions, such
as C<print> and C<chdir>. As such, you can find information about them in
L<Functions.pod>. Parentheses are still used for grouping.

=head2 The Arrow Operator

As you typically will not be using references in Perl 6, the arrow is
probably less useful as a dereferencing operator. If you do need to
dereference something, however, the arrow is now the dot. It is also now
the dot for method calls. So, C<$arrayref->[7]> becomes C<$arrayref.[7]>
and C<$user->name> becomes C<$user.name>. The C<< => >> arrow is now
used for constructing Pairs, see
L<http://doc.perl6.org/language/terms#Pair>.

=head2 Auto-increment and Auto-decrement

Still work as in Perl 5. The one possible caveat is that they now function by
calling the C<succ> method for C<++> and the C<pred> method for C<-->. For
builtin numeric types, this is unlikely to do something unusual, but custom
types can define their own C<succ> and C<pred> methods, so in those cases, you
should probably take note of what C<++> and C<--> will I<actually> do.

=head2 Exponentiation

Still works as you would expect. The caveat in Perl 5's perlop about C<**>
binding more tightly than unary minus (i. e. "-2**4" evaluates as "-(2**4)"
rather than "(-2)**4)") still seems to hold true.

=head2 Symbolic Unary Operators

Unary C<!> and C<-> still do logical arithmetic negation, respectively. C<?^>
is used for bitwise logical negation, which the documentation indicates is
equivalent to C<!>. It may be relevant to note that these now coerce their
arguments to C<Bool> and C<Numeric>, respectively.

Unary C<~> is now the string context operator, so use prefix C<+^> for
bitwise integer negation. Assumes two's complement.

C<+> now I<does> have an effect, coercing its argument to to the Numeric type.

Unary <\> is no more. If you really want to take a reference to an existing
named variable, you can use item context, like so: C<$aref = item(@array)>
You can get a reference to a named subroutine by using the C<&> sigil: <$sref
= &foo> Anonymous arrays, hashes, and subs return their references during
creation.

=head2 Binding Operators

C<=~> and C<!~> have been replaced by C<~~> and C<!~~>, respectively. Those of
you who consider smart matching broken in Perl 5 will be happy to hear that it
works much better in Perl 6, as the stronger typing means less guesswork.

=head2 Multiplicative Operators

Binary C<*>, C</>, and C<%> still do multiplication, division, and modulo,
respectively.

Binary C<x> has changed slightly and gotten a companion. C<print '-' x 80;>
still gives you a string of 80 dashes, but for the old behavior of C<@ones =
(1) x 80;> giving you a list of 80 "1"s, you would now use C<@ones = 1 xx
80;>.

=head2 Additive Operators

Binary C<+> and <-> still do addition and subtraction, respectively.

C<.> is now the method call operator, so binary C<~> now acts as the
concatenation operator.

=head2 Shift Operators

C<< << >> and C<< >> >> have been replaced by C<< +< >> and C<< +> >>.

=head2 Named Unary Operators

As noted above, you'll find these in L<Functions.pod>.

=head2 Relational Operators

These all work as in Perl 5.

=head2 Equality Operators

C<==> and C<!=> both work as in Perl 5.

C<< <=> >> and C<cmp> have changed. C<< <=> >> still does a numeric
comparison, but returns <Order::Less>, <Order::Same>, or <Order::More> instead
of Perl 5's C<-1>, C<0>, or C<1>. To get the old behavior (with the change
that it returns the C<Order> objects, rather than integers) of C<cmp>, you
would now use the C<leg> operator.

C<cmp> now does either C<< <=> >> or C<leg>, depending on the existing type of
its arguments.

C<~~> is still the smart match operator, but it's also now just the match
operator, as noted above. For how smart matching works in Perl 6, see
L<http://design.perl6.org/S03.html#Smart_matching>.

=head2 Smartmatch Operator

See the entry on C<~~> directly above.

=head2 Bitwise And

Binary C<&> is now C<+&>.

=head2 Bitwise Or and Exclusive Or

Bitwise OR has changed from C<|> to C<+|>. Bitwise XOR has changed from C<^>
to C<+^>

=head2 C-style Logical And

Unchanged.

=head2 C-style Logical Or

Unchanged.

=head2 Logical Defined-Or

Still there. Now defined as returning the first defined operand, although it
appears to return the last operand if none of the operands are defined, so
that may need a tweak. Also, there is now a low precedence version, called
C<orelse>.

=head2 Range Operators

In list context, C<..> still operates as the range operator and should not
need to be changed. That said, there are now exclusionary range operators that
may be useful. These are:

infix  ..^  Excludes endpoint. C<1..^5; # 1 2 3 4 >
infix  ^..  Excludes startpoint. C<1^..5; # 2 3 4 5>
infix  ^..^ Excludes both start- and endpoint. C<1^..^5; # 2 3 4>
prefix ^    From 0, excludes endpoint. C<^5; # 0 1 2 3 4>

In scalar context, C<..> and C<...> worked as flip-flop operators, but were
little-known, and probably even less used. Those operations have been taken
over by C<ff> and C<fff>, but are not clearly documented at this time.

=head2 Conditional Operator

C<?:> has been changed to C<?? !!>. I. e. where you would use C<$x = $ok
? $y : $z;> in Perl 5, you would use C<$x = $ok ?? $y !! $z;> in Perl 6.

=head2 Assignment Operators

Although not fully documented, S03 indicates that the mathematical and logical
assignment operators should work as you would expect. The one noticeable change
is that C<.=> now calls a mutating method on the object on the left, while
C<~=> is now the string concatenation assignment, as you might expect with the
changes in C<.> and C<~>. Also, the bitwise assignment operators are likely
not separated into numeric and string versions (C<&=>, etc., vs. C<&.=>, etc.),
as that feature is currently experimental in Perl 5 itself - although, again,
this is not specifically documented.

=head2 Comma Operator

The comma operator still works mostly as expected, but technically it now
creates Parcels (see L<http://doc.perl6.org/type/Parcel>) or separates
arguments in function calls. Also, there is a C<:> variant that turns function
calls into method calls - see
L<http://doc.perl6.org/language/operators#infix_%3A>.

The C<< => >> operator works similarly to the old "fat comma" behavior in that
it allows an unquoted identifier on its left side, but now constructs Pair
objects, rather than just functioning as a separator. If you are trying to
just literally translate a line of Perl 5 code to Perl 6, it should behave as
expected.

=head2 List Operators (Rightward)

Like the Named Unary Operators, you'll find these discussed in
L<Functions.pod>.

=head2 Logical Not

Still the lower precedence version of C<!>. As with C<!>, now coerces its
argument to C<Bool>.

=head2 Logical And

Lower precedence version of C<&&> as before.

=head2 Logical or and Exclusive Or

C<or> is still the low precedence version of C<||>. The documentation lists an
C<xor>, but does not actually document it.

Additionally, there is now a low precedence version of C<//>, called
C<orelse>. Unlike C<//>, this is documented to return the last argument if
there is no defined argument.

=head2 Quote and Quote-like Operators

For all the gory details on quoting constructs, see
L<http://doc.perl6.org/language/quoting>.

There is now a quoting operator that allows absolute literal strings: C<Q> or
C<｢…｣>, although the latter might be difficult to find on your keyboard,
depending on your keyboard... Backslash escapes do I<not> apply in C<Q> quoted
strings. E. g. C<Q{This is still a closing brace → \}> renders "This is still a
closing brace → \".

C<q> still does what you expect, allowing backslash escapes. E. g. C<q{This is
not a closing brace → \}, but this is → }> returning "This is not a closing
brace → }, but this is →". As in Perl 5, you can get this behavior with single
quotes.

C<qq> still allows interpolation of variables. However, by default, only
scalar variables are now interpolated. To get other variables to interpolate,
you need to put square brackets after them. E. g. C<< @a = <1 2 3>;say qq/@a[]
example@example.com/; >> results in "1 2 3 example@example.com". Hashes
interpolate in a possibly unexpected manner: C<< %a = 1 => 2, 3 => 4;say
"%a[]"; >> results in a space separating the pairs and tabs separating the key
from the value in each pair (apparently). You can also interpolate Perl 6 code
in strings using curly braces. For all the details, see
L<http://doc.perl6.org/language/quoting#Interpolation%3A_qq>.

C<qw> still works, and can also be rendered as C<< <...> >>. E. g. C<qw/a b
c/> is equivalent to C<< <a b c> >>.

There is also now a version of C<qw> that interpolates, which is C<qqw>. So
C<my $a = 42;say qqw/$a b c/;> gives you "42 b c".

Shell quoting is still available through C<qx>, but you should note that
backticks no longer do shell quoting, and Perl variables are I<not>
interpolated in C<qx> strings. If you need to interpolate Perl variables in a
shell command string, you can use C<qqx> instead.

The C<qr> operator is gone.

C<tr///> is not well documented, but seems to work similarly to how it
does in Perl 5. The one caveat is that ranges are specified differently.
Instead of using a range "a-z", you would now use "a..z", i. e. with
Perl's range operator. C<tr///> now has a method version, which is
better documented, called C<.trans>. C<.trans> uses a list of pairs, as
follows: C<< $x.trans(['a'..'c'] => ['A'..'C'], ['d'..'q'] =>
['D'..'Q'], ['r'..'z'] => ['R'..'Z']); >> A much more extensive
description of the uses of C<.trans> can be found at
L<http://design.perl6.org/S05.html#Transliteration>. The C<y///>
equivalent has been done away with.

Heredocs are specified differently in Perl 6. You use C<:to> with your quoting
operator, e. g. C<q:to/END/;> would start a heredoc ending with "END".
Similarly, you get escaping and interpolation based on your quoting operator,
i. e. literals with C<Q>, backslash escapes with C<q>, and interpolation with
C<qq>.

=head2 I/O Operators

The full details on Input/Output in Perl 6 can be found at
L<http://doc.perl6.org/language/io>.

As C<< <...> >> is now the quote-words construct, C<< <> >> is no longer
used for reading lines from a file. You can now do that by either making an
C<IO> object from a file name or using an open filehandle and then, in either case,
calling C<.lines> on it. I. e. either C<my @a = "filename".IO.lines;> or
C<my $fh = open "filename", :r;my @a = $fh.lines;> (In the latter case, we are
using C<:r> to specifically open the file for reading). To do this in an
iterative manner, you can use a C<for> loop this way:

=begin code

for 'huge-csv'.IO.lines -> $line {
    # Do something with $line
}

=end code

Note the use of C<< -> >> there. That's part of the Block syntax, and is
now needed for C<if>, C<for>, C<while>, etc.

If you want to slurp the entire file into a scalar, you would - surprise! -
use the C<.slurp> method. For instance, C<my $x = "filename".IO.slurp;> or
C<my $fh = open "filename", :r;my $x = $fh.slurp;>.

As noted in L<Special_Variables.pod>, the C<ARGV> magic input filehandle has
been replaced by C<$*ARGFILES>, and the C<@ARGV> array of command line
arguments has been replaced by C<@*ARGS>.

=head2 No-ops

Although it's not specifically documented, C<1 while foo();> still appears to
work in this sense.

=head2 Bitwise String Operators

Documented individually above, but to summarize...

Bitwise integer negation is now prefix C<+^>. Bitwise boolean negation
is now C<?^>.

Bitwise and is now C<+&>.

Bitwise integer or is now C<+|>. Bitwise integer xor is now infix C<+^>.
Bitwise boolean or is now <?|>.

Left shift and right shift are now C<< +< >> and C<< +> >>.

=end pod
